# inline blob

Создадим таблицу, в которой будут хранится файлы. Для примера я загрузил в эту таблицу содержимое исходных кодов библиотеки lucene_udr (https://github.com/IBSurgeon/lucene_udr/tree/main/src). Файлы исходных кодов могут быть короткими и длинными, поэтому для демонстрации передачи BLOB по сети они подходят идеально.

```sql
CREATE TABLE BLOB_SAMPLE (
    ID         BIGINT GENERATED BY DEFAULT AS IDENTITY,
    FILE_NAME  VARCHAR(255) CHARACTER SET UTF8 NOT NULL,
    CONTENT    BLOB SUB_TYPE TEXT CHARACTER SET UTF8
);

ALTER TABLE BLOB_SAMPLE ADD PRIMARY KEY (ID);
ALTER TABLE BLOB_SAMPLE ADD UNIQUE (FILE_NAME);
```

В данной библиотеке не так много файлов, поэтому масштабируем их количество перезалив BLOB в другую таблицу. Заодно добавим туда дополнительные поля.

```sql
RECREATE TABLE BLOB_TEST (
    ID             BIGINT GENERATED BY DEFAULT AS IDENTITY,
    SHORT_CONTENT  VARCHAR(8191) CHARACTER SET UTF8,
    CONTENT        BLOB SUB_TYPE TEXT CHARACTER SET UTF8,
    SHORT_BLOB     BOOLEAN DEFAULT FALSE NOT NULL,
	CONSTRAINT PK_BLOB_TEST PRIMARY KEY (ID)
);
```

Заполняем тестовую таблицу 

```sql
SET TERM ^;

EXECUTE BLOCK
AS
DECLARE I INTEGER = 0;
DECLARE IS_SHORT BOOLEAN;
BEGIN
  WHILE (TRUE) DO
  BEGIN
    FOR
      SELECT
        ID,
        FILE_NAME,
        CONTENT,
        CHAR_LENGTH(CONTENT) AS CH_L,
        OCTET_LENGTH(CONTENT) AS OC_L
      FROM BLOB_SAMPLE
      ORDER BY FILE_NAME
      AS CURSOR C
    DO
    BEGIN
      I = I + 1;
      -- BLOB помещается в строковую переменную 8191
      IS_SHORT = (C.CH_L < 8191);

      INSERT INTO BLOB_TEST (
        SHORT_CONTENT,
        CONTENT,
        SHORT_BLOB
      )
      VALUES (
        IIF(:IS_SHORT, :C.CONTENT, NULL), -- если BLOB короткий пишем в VARCHAR поле
        :C.CONTENT,
        :IS_SHORT
      );
      -- выходим когда вставлено 10000 записей
      IF (I = 10000) THEN EXIT;
    END
  END
END^

SET TERM ;^

COMMIT;
```
